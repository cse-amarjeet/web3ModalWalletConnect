{"ast":null,"code":"import { HttpRequestError, TimeoutError, WebSocketRequestError } from '../errors/request.js';\nimport { createBatchScheduler } from './promise/createBatchScheduler.js';\nimport { withTimeout } from './promise/withTimeout.js';\nimport { stringify } from './stringify.js';\nlet id = 0;\nasync function http(url, _ref) {\n  let {\n    body,\n    fetchOptions = {},\n    timeout = 10000\n  } = _ref;\n  const {\n    headers,\n    method,\n    signal: signal_\n  } = fetchOptions;\n  try {\n    const response = await withTimeout(async _ref2 => {\n      let {\n        signal\n      } = _ref2;\n      const response = await fetch(url, {\n        ...fetchOptions,\n        body: Array.isArray(body) ? stringify(body.map(body => ({\n          jsonrpc: '2.0',\n          id: id++,\n          ...body\n        }))) : stringify({\n          jsonrpc: '2.0',\n          id: id++,\n          ...body\n        }),\n        headers: {\n          ...headers,\n          'Content-Type': 'application/json'\n        },\n        method: method || 'POST',\n        signal: signal_ || (timeout > 0 ? signal : undefined)\n      });\n      return response;\n    }, {\n      errorInstance: new TimeoutError({\n        body,\n        url\n      }),\n      timeout,\n      signal: true\n    });\n    let data;\n    if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n      data = await response.json();\n    } else {\n      data = await response.text();\n    }\n    if (!response.ok) {\n      throw new HttpRequestError({\n        body,\n        details: stringify(data.error) || response.statusText,\n        headers: response.headers,\n        status: response.status,\n        url\n      });\n    }\n    return data;\n  } catch (err) {\n    if (err instanceof HttpRequestError) throw err;\n    if (err instanceof TimeoutError) throw err;\n    throw new HttpRequestError({\n      body,\n      details: err.message,\n      url\n    });\n  }\n}\nconst sockets = /*#__PURE__*/new Map();\nexport async function getSocket(url_) {\n  const url = new URL(url_);\n  const urlKey = url.toString();\n  let socket = sockets.get(urlKey);\n  // If the socket already exists, return it.\n  if (socket) return socket;\n  const {\n    schedule\n  } = createBatchScheduler({\n    id: urlKey,\n    fn: async () => {\n      let WebSocket = await import('isomorphic-ws');\n      // Workaround for Vite.\n      // https://github.com/vitejs/vite/issues/9703\n      // TODO: Remove when issue is resolved.\n      if (WebSocket.default?.constructor) WebSocket = WebSocket.default;else WebSocket = WebSocket.WebSocket;\n      const webSocket = new WebSocket(url);\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map();\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map();\n      const onMessage = _ref3 => {\n        let {\n          data\n        } = _ref3;\n        const message = JSON.parse(data);\n        const isSubscription = message.method === 'eth_subscription';\n        const id = isSubscription ? message.params.subscription : message.id;\n        const cache = isSubscription ? subscriptions : requests;\n        const callback = cache.get(id);\n        if (callback) callback({\n          data\n        });\n        if (!isSubscription) cache.delete(id);\n      };\n      const onClose = () => {\n        sockets.delete(urlKey);\n        webSocket.removeEventListener('close', onClose);\n        webSocket.removeEventListener('message', onMessage);\n      };\n      // Setup event listeners for RPC & subscription responses.\n      webSocket.addEventListener('close', onClose);\n      webSocket.addEventListener('message', onMessage);\n      // Wait for the socket to open.\n      if (webSocket.readyState === WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!webSocket) return;\n          webSocket.onopen = resolve;\n          webSocket.onerror = reject;\n        });\n      }\n      // Create a new socket instance.\n      socket = Object.assign(webSocket, {\n        requests,\n        subscriptions\n      });\n      sockets.set(urlKey, socket);\n      return [socket];\n    }\n  });\n  const [_, [socket_]] = await schedule();\n  return socket_;\n}\nfunction webSocket(socket, _ref4) {\n  let {\n    body,\n    onResponse\n  } = _ref4;\n  if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) throw new WebSocketRequestError({\n    body,\n    url: socket.url,\n    details: 'Socket is closed.'\n  });\n  const id_ = id++;\n  const callback = _ref5 => {\n    let {\n      data\n    } = _ref5;\n    const message = JSON.parse(data);\n    if (typeof message.id === 'number' && id_ !== message.id) return;\n    onResponse?.(message);\n    // If we are subscribing to a topic, we want to set up a listener for incoming\n    // messages.\n    if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\n      socket.subscriptions.set(message.result, callback);\n    }\n    // If we are unsubscribing from a topic, we want to remove the listener.\n    if (body.method === 'eth_unsubscribe') {\n      socket.subscriptions.delete(body.params?.[0]);\n    }\n  };\n  socket.requests.set(id_, callback);\n  socket.send(JSON.stringify({\n    jsonrpc: '2.0',\n    ...body,\n    id: id_\n  }));\n  return socket;\n}\nasync function webSocketAsync(socket, _ref6) {\n  let {\n    body,\n    timeout = 10000\n  } = _ref6;\n  return withTimeout(() => new Promise(onResponse => rpc.webSocket(socket, {\n    body,\n    onResponse\n  })), {\n    errorInstance: new TimeoutError({\n      body,\n      url: socket.url\n    }),\n    timeout\n  });\n}\n///////////////////////////////////////////////////\nexport const rpc = {\n  http,\n  webSocket,\n  webSocketAsync\n};","map":{"version":3,"names":["HttpRequestError","TimeoutError","WebSocketRequestError","createBatchScheduler","withTimeout","stringify","id","http","url","_ref","body","fetchOptions","timeout","headers","method","signal","signal_","response","_ref2","fetch","Array","isArray","map","jsonrpc","undefined","errorInstance","data","get","startsWith","json","text","ok","details","error","statusText","status","err","message","sockets","Map","getSocket","url_","URL","urlKey","toString","socket","schedule","fn","WebSocket","default","constructor","webSocket","requests","subscriptions","onMessage","_ref3","JSON","parse","isSubscription","params","subscription","cache","callback","delete","onClose","removeEventListener","addEventListener","readyState","CONNECTING","Promise","resolve","reject","onopen","onerror","Object","assign","set","_","socket_","_ref4","onResponse","CLOSED","CLOSING","id_","_ref5","result","send","webSocketAsync","_ref6","rpc"],"sources":["/home/amarjeet/Amarjeet/realwareWeb3/metamask_sign/Dapp-Starter code/node_modules/viem/src/utils/rpc.ts"],"sourcesContent":["import type { MessageEvent, WebSocket } from 'isomorphic-ws'\n\nimport {\n  HttpRequestError,\n  TimeoutError,\n  WebSocketRequestError,\n} from '../errors/request.js'\n\nimport { createBatchScheduler } from './promise/createBatchScheduler.js'\nimport { withTimeout } from './promise/withTimeout.js'\nimport { stringify } from './stringify.js'\n\nlet id = 0\n\ntype SuccessResult<T> = {\n  method?: never\n  result: T\n  error?: never\n}\ntype ErrorResult<T> = {\n  method?: never\n  result?: never\n  error: T\n}\ntype Subscription<TResult, TError> = {\n  method: 'eth_subscription'\n  error?: never\n  result?: never\n  params: {\n    subscription: string\n  } & (\n    | {\n        result: TResult\n        error?: never\n      }\n    | {\n        result?: never\n        error: TError\n      }\n  )\n}\n\nexport type RpcRequest = { method: string; params?: any }\n\nexport type RpcResponse<TResult = any, TError = any> = {\n  jsonrpc: `${number}`\n  id: number\n} & (\n  | SuccessResult<TResult>\n  | ErrorResult<TError>\n  | Subscription<TResult, TError>\n)\n\n///////////////////////////////////////////////////\n// HTTP\n\nexport type HttpOptions<TBody extends RpcRequest | RpcRequest[] = RpcRequest,> =\n  {\n    // The RPC request body.\n    body: TBody\n    // Request configuration to pass to `fetch`.\n    fetchOptions?: Omit<RequestInit, 'body'>\n    // The timeout (in ms) for the request.\n    timeout?: number\n  }\n\nexport type HttpReturnType<\n  TBody extends RpcRequest | RpcRequest[] = RpcRequest,\n> = TBody extends RpcRequest[] ? RpcResponse[] : RpcResponse\n\nasync function http<TBody extends RpcRequest | RpcRequest[]>(\n  url: string,\n  { body, fetchOptions = {}, timeout = 10_000 }: HttpOptions<TBody>,\n): Promise<HttpReturnType<TBody>> {\n  const { headers, method, signal: signal_ } = fetchOptions\n  try {\n    const response = await withTimeout(\n      async ({ signal }) => {\n        const response = await fetch(url, {\n          ...fetchOptions,\n          body: Array.isArray(body)\n            ? stringify(\n                body.map((body) => ({\n                  jsonrpc: '2.0',\n                  id: id++,\n                  ...body,\n                })),\n              )\n            : stringify({ jsonrpc: '2.0', id: id++, ...body }),\n          headers: {\n            ...headers,\n            'Content-Type': 'application/json',\n          },\n          method: method || 'POST',\n          signal: signal_ || (timeout > 0 ? signal : undefined),\n        })\n        return response\n      },\n      {\n        errorInstance: new TimeoutError({ body, url }),\n        timeout,\n        signal: true,\n      },\n    )\n\n    let data\n    if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n      data = await response.json()\n    } else {\n      data = await response.text()\n    }\n\n    if (!response.ok) {\n      throw new HttpRequestError({\n        body,\n        details: stringify(data.error) || response.statusText,\n        headers: response.headers,\n        status: response.status,\n        url,\n      })\n    }\n\n    return data\n  } catch (err) {\n    if (err instanceof HttpRequestError) throw err\n    if (err instanceof TimeoutError) throw err\n    throw new HttpRequestError({\n      body,\n      details: (err as Error).message,\n      url,\n    })\n  }\n}\n\n///////////////////////////////////////////////////\n// WebSocket\n\ntype Id = string | number\ntype CallbackFn = (message: any) => void\ntype CallbackMap = Map<Id, CallbackFn>\n\nexport type Socket = WebSocket & {\n  requests: CallbackMap\n  subscriptions: CallbackMap\n}\n\nconst sockets = /*#__PURE__*/ new Map<string, Socket>()\n\nexport async function getSocket(url_: string) {\n  const url = new URL(url_)\n  const urlKey = url.toString()\n\n  let socket = sockets.get(urlKey)\n\n  // If the socket already exists, return it.\n  if (socket) return socket\n\n  const { schedule } = createBatchScheduler<undefined, [Socket]>({\n    id: urlKey,\n    fn: async () => {\n      let WebSocket = await import('isomorphic-ws')\n      // Workaround for Vite.\n      // https://github.com/vitejs/vite/issues/9703\n      // TODO: Remove when issue is resolved.\n      if (\n        (WebSocket as unknown as { default?: typeof WebSocket }).default\n          ?.constructor\n      )\n        WebSocket = (WebSocket as unknown as { default: typeof WebSocket })\n          .default\n      else WebSocket = WebSocket.WebSocket\n\n      const webSocket = new WebSocket(url)\n\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map<Id, CallbackFn>()\n\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map<Id, CallbackFn>()\n\n      const onMessage: (event: MessageEvent) => void = ({ data }) => {\n        const message: RpcResponse = JSON.parse(data as string)\n        const isSubscription = message.method === 'eth_subscription'\n        const id = isSubscription ? message.params.subscription : message.id\n        const cache = isSubscription ? subscriptions : requests\n        const callback = cache.get(id)\n        if (callback) callback({ data })\n        if (!isSubscription) cache.delete(id)\n      }\n      const onClose = () => {\n        sockets.delete(urlKey)\n        webSocket.removeEventListener('close', onClose)\n        webSocket.removeEventListener('message', onMessage)\n      }\n\n      // Setup event listeners for RPC & subscription responses.\n      webSocket.addEventListener('close', onClose)\n      webSocket.addEventListener('message', onMessage)\n\n      // Wait for the socket to open.\n      if (webSocket.readyState === WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!webSocket) return\n          webSocket.onopen = resolve\n          webSocket.onerror = reject\n        })\n      }\n\n      // Create a new socket instance.\n      socket = Object.assign(webSocket, {\n        requests,\n        subscriptions,\n      })\n      sockets.set(urlKey, socket)\n\n      return [socket]\n    },\n  })\n\n  const [_, [socket_]] = await schedule()\n  return socket_\n}\n\nexport type WebSocketOptions = {\n  /** The RPC request body. */\n  body: RpcRequest\n  /** The callback to invoke on response. */\n  onResponse?: (message: RpcResponse) => void\n}\n\nexport type WebSocketReturnType = Socket\n\nfunction webSocket(\n  socket: Socket,\n  { body, onResponse }: WebSocketOptions,\n): WebSocketReturnType {\n  if (\n    socket.readyState === socket.CLOSED ||\n    socket.readyState === socket.CLOSING\n  )\n    throw new WebSocketRequestError({\n      body,\n      url: socket.url,\n      details: 'Socket is closed.',\n    })\n\n  const id_ = id++\n\n  const callback = ({ data }: { data: any }) => {\n    const message: RpcResponse = JSON.parse(data)\n\n    if (typeof message.id === 'number' && id_ !== message.id) return\n\n    onResponse?.(message)\n\n    // If we are subscribing to a topic, we want to set up a listener for incoming\n    // messages.\n    if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\n      socket.subscriptions.set(message.result, callback)\n    }\n\n    // If we are unsubscribing from a topic, we want to remove the listener.\n    if (body.method === 'eth_unsubscribe') {\n      socket.subscriptions.delete(body.params?.[0])\n    }\n  }\n  socket.requests.set(id_, callback)\n\n  socket.send(JSON.stringify({ jsonrpc: '2.0', ...body, id: id_ }))\n\n  return socket\n}\n\nexport type WebSocketAsyncOptions = {\n  /** The RPC request body. */\n  body: RpcRequest\n  /** The timeout (in ms) for the request. */\n  timeout?: number\n}\n\nexport type WebSocketAsyncReturnType = RpcResponse\n\nasync function webSocketAsync(\n  socket: Socket,\n  { body, timeout = 10_000 }: WebSocketAsyncOptions,\n): Promise<WebSocketAsyncReturnType> {\n  return withTimeout(\n    () =>\n      new Promise<RpcResponse>((onResponse) =>\n        rpc.webSocket(socket, {\n          body,\n          onResponse,\n        }),\n      ),\n    {\n      errorInstance: new TimeoutError({ body, url: socket.url }),\n      timeout,\n    },\n  )\n}\n\n///////////////////////////////////////////////////\n\nexport const rpc = {\n  http,\n  webSocket,\n  webSocketAsync,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}