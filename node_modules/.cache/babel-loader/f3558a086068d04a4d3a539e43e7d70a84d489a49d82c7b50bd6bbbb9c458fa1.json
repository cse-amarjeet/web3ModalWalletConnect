{"ast":null,"code":"import { DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../errors/abi.js';\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js';\nimport { encodeEventTopics } from '../../utils/abi/encodeEventTopics.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { formatLog } from '../../utils/formatters/log.js';\n/**\n * Returns a list of event logs matching the provided parameters.\n *\n * - Docs: https://viem.sh/docs/actions/public/getLogs.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/filters-and-logs/event-logs\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetLogsParameters}\n * @returns A list of event logs. {@link GetLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getLogs(client)\n */\nexport async function getLogs(client) {\n  let {\n    address,\n    blockHash,\n    fromBlock,\n    toBlock,\n    event,\n    args,\n    strict: strict_\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const strict = strict_ ?? false;\n  let topics = [];\n  if (event) topics = encodeEventTopics({\n    abi: [event],\n    eventName: event.name,\n    args\n  });\n  let logs;\n  if (blockHash) {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [{\n        address,\n        topics,\n        blockHash\n      }]\n    });\n  } else {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [{\n        address,\n        topics,\n        fromBlock: typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock\n      }]\n    });\n  }\n  return logs.map(log => {\n    try {\n      const {\n        eventName,\n        args\n      } = event ? decodeEventLog({\n        abi: [event],\n        data: log.data,\n        topics: log.topics,\n        strict\n      }) : {\n        eventName: undefined,\n        args: undefined\n      };\n      return formatLog(log, {\n        args,\n        eventName\n      });\n    } catch (err) {\n      let eventName;\n      let isUnnamed;\n      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\n        // If strict mode is on, and log data/topics do not match event definition, skip.\n        if (strict) return;\n        eventName = err.abiItem.name;\n        isUnnamed = err.abiItem.inputs?.some(x => !('name' in x && x.name));\n      }\n      // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n      return formatLog(log, {\n        args: isUnnamed ? [] : {},\n        eventName\n      });\n    }\n  }).filter(Boolean);\n}","map":{"version":3,"names":["DecodeLogDataMismatch","DecodeLogTopicsMismatch","decodeEventLog","encodeEventTopics","numberToHex","formatLog","getLogs","client","address","blockHash","fromBlock","toBlock","event","args","strict","strict_","arguments","length","undefined","topics","abi","eventName","name","logs","request","method","params","map","log","data","err","isUnnamed","abiItem","inputs","some","x","filter","Boolean"],"sources":["/home/amarjeet/Amarjeet/realwareWeb3/metamask_sign/Dapp-Starter code/node_modules/viem/src/actions/public/getLogs.ts"],"sourcesContent":["import type { AbiEvent, Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hash, LogTopic } from '../../types/misc.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { formatLog } from '../../utils/formatters/log.js'\n\nexport type GetLogsParameters<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TStrict extends boolean | undefined = undefined,\n  _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = {\n  /** Address or list of addresses from which logs originated */\n  address?: Address | Address[]\n} & (\n  | {\n      event: Narrow<TAbiEvent>\n      args?: MaybeExtractEventArgsFromAbi<[TAbiEvent], _EventName>\n      /**\n       * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n       * @default false\n       */\n      strict?: TStrict\n    }\n  | {\n      event?: never\n      args?: never\n      strict?: never\n    }\n) &\n  (\n    | {\n        /** Block number or tag after which to include logs */\n        fromBlock?: BlockNumber<bigint> | BlockTag\n        /** Block number or tag before which to include logs */\n        toBlock?: BlockNumber<bigint> | BlockTag\n        blockHash?: never\n      }\n    | {\n        fromBlock?: never\n        toBlock?: never\n        /** Hash of block to include logs from */\n        blockHash?: Hash\n      }\n  )\n\nexport type GetLogsReturnType<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TStrict extends boolean | undefined = undefined,\n  _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = Log<bigint, number, TAbiEvent, TStrict, [TAbiEvent], _EventName>[]\n\n/**\n * Returns a list of event logs matching the provided parameters.\n *\n * - Docs: https://viem.sh/docs/actions/public/getLogs.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/filters-and-logs/event-logs\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetLogsParameters}\n * @returns A list of event logs. {@link GetLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getLogs(client)\n */\nexport async function getLogs<\n  TChain extends Chain | undefined,\n  TAbiEvent extends AbiEvent | undefined,\n  TStrict extends boolean | undefined = undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    address,\n    blockHash,\n    fromBlock,\n    toBlock,\n    event,\n    args,\n    strict: strict_,\n  }: GetLogsParameters<TAbiEvent, TStrict> = {},\n): Promise<GetLogsReturnType<TAbiEvent, TStrict>> {\n  const strict = strict_ ?? false\n\n  let topics: LogTopic[] = []\n  if (event)\n    topics = encodeEventTopics({\n      abi: [event],\n      eventName: (event as AbiEvent).name,\n      args,\n    } as EncodeEventTopicsParameters)\n\n  let logs: RpcLog[]\n  if (blockHash) {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [{ address, topics, blockHash }],\n    })\n  } else {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [\n        {\n          address,\n          topics,\n          fromBlock:\n            typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n          toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        },\n      ],\n    })\n  }\n\n  return logs\n    .map((log) => {\n      try {\n        const { eventName, args } = event\n          ? decodeEventLog({\n              abi: [event] as [AbiEvent],\n              data: log.data,\n              topics: log.topics as any,\n              strict,\n            })\n          : { eventName: undefined, args: undefined }\n        return formatLog(log, { args, eventName })\n      } catch (err) {\n        let eventName\n        let isUnnamed\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return formatLog(log, { args: isUnnamed ? [] : {}, eventName })\n      }\n    })\n    .filter(Boolean) as unknown as GetLogsReturnType<TAbiEvent, TStrict>\n}\n"],"mappings":"AAIA,SACEA,qBAAqB,EACrBC,uBAAuB,QAClB,qBAAqB;AAU5B,SAASC,cAAc,QAAQ,mCAAmC;AAClE,SAEEC,iBAAiB,QACZ,sCAAsC;AAC7C,SAASC,WAAW,QAAQ,+BAA+B;AAC3D,SAASC,SAAS,QAAQ,+BAA+B;AA+CzD;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAO,eAAeC,OAAOA,CAK3BC,MAAiC,EASY;EAAA,IAR7C;IACEC,OAAO;IACPC,SAAS;IACTC,SAAS;IACTC,OAAO;IACPC,KAAK;IACLC,IAAI;IACJC,MAAM,EAAEC;EAAO,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAC0B,EAAE;EAE7C,MAAMF,MAAM,GAAGC,OAAO,IAAI,KAAK;EAE/B,IAAII,MAAM,GAAe,EAAE;EAC3B,IAAIP,KAAK,EACPO,MAAM,GAAGhB,iBAAiB,CAAC;IACzBiB,GAAG,EAAE,CAACR,KAAK,CAAC;IACZS,SAAS,EAAGT,KAAkB,CAACU,IAAI;IACnCT;GAC8B,CAAC;EAEnC,IAAIU,IAAc;EAClB,IAAId,SAAS,EAAE;IACbc,IAAI,GAAG,MAAMhB,MAAM,CAACiB,OAAO,CAAC;MAC1BC,MAAM,EAAE,aAAa;MACrBC,MAAM,EAAE,CAAC;QAAElB,OAAO;QAAEW,MAAM;QAAEV;MAAS,CAAE;KACxC,CAAC;GACH,MAAM;IACLc,IAAI,GAAG,MAAMhB,MAAM,CAACiB,OAAO,CAAC;MAC1BC,MAAM,EAAE,aAAa;MACrBC,MAAM,EAAE,CACN;QACElB,OAAO;QACPW,MAAM;QACNT,SAAS,EACP,OAAOA,SAAS,KAAK,QAAQ,GAAGN,WAAW,CAACM,SAAS,CAAC,GAAGA,SAAS;QACpEC,OAAO,EAAE,OAAOA,OAAO,KAAK,QAAQ,GAAGP,WAAW,CAACO,OAAO,CAAC,GAAGA;OAC/D;KAEJ,CAAC;;EAGJ,OAAOY,IAAI,CACRI,GAAG,CAAEC,GAAG,IAAI;IACX,IAAI;MACF,MAAM;QAAEP,SAAS;QAAER;MAAI,CAAE,GAAGD,KAAK,GAC7BV,cAAc,CAAC;QACbkB,GAAG,EAAE,CAACR,KAAK,CAAe;QAC1BiB,IAAI,EAAED,GAAG,CAACC,IAAI;QACdV,MAAM,EAAES,GAAG,CAACT,MAAa;QACzBL;OACD,CAAC,GACF;QAAEO,SAAS,EAAEH,SAAS;QAAEL,IAAI,EAAEK;MAAS,CAAE;MAC7C,OAAOb,SAAS,CAACuB,GAAG,EAAE;QAAEf,IAAI;QAAEQ;MAAS,CAAE,CAAC;KAC3C,CAAC,OAAOS,GAAG,EAAE;MACZ,IAAIT,SAAS;MACb,IAAIU,SAAS;MACb,IACED,GAAG,YAAY9B,qBAAqB,IACpC8B,GAAG,YAAY7B,uBAAuB,EACtC;QACA;QACA,IAAIa,MAAM,EAAE;QACZO,SAAS,GAAGS,GAAG,CAACE,OAAO,CAACV,IAAI;QAC5BS,SAAS,GAAGD,GAAG,CAACE,OAAO,CAACC,MAAM,EAAEC,IAAI,CAAEC,CAAC,IAAK,EAAE,MAAM,IAAIA,CAAC,IAAIA,CAAC,CAACb,IAAI,CAAC,CAAC;;MAGvE;MACA,OAAOjB,SAAS,CAACuB,GAAG,EAAE;QAAEf,IAAI,EAAEkB,SAAS,GAAG,EAAE,GAAG,EAAE;QAAEV;MAAS,CAAE,CAAC;;EAEnE,CAAC,CAAC,CACDe,MAAM,CAACC,OAAO,CAAqD;AACxE"},"metadata":{},"sourceType":"module","externalDependencies":[]}