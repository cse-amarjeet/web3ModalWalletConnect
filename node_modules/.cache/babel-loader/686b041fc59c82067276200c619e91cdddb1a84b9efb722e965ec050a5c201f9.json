{"ast":null,"code":"import { singleAddressResolverAbi, universalResolverResolveAbi } from '../../constants/abis.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress } from '../../utils/chain.js';\nimport { trim } from '../../utils/data/trim.js';\nimport { toHex } from '../../utils/encoding/toHex.js';\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js';\nimport { namehash } from '../../utils/ens/namehash.js';\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js';\nimport { readContract } from '../public/readContract.js';\n/**\n * Gets address for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAddressParameters}\n * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAddress, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAddress = await getEnsAddress(client, {\n *   name: normalize('wagmi-dev.eth'),\n * })\n * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n */\nexport async function getEnsAddress(client, _ref) {\n  let {\n    blockNumber,\n    blockTag,\n    name,\n    universalResolverAddress: universalResolverAddress_\n  } = _ref;\n  let universalResolverAddress = universalResolverAddress_;\n  if (!universalResolverAddress) {\n    if (!client.chain) throw new Error('client chain not configured. universalResolverAddress is required.');\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver'\n    });\n  }\n  try {\n    const res = await readContract(client, {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolve',\n      args: [toHex(packetToBytes(name)), encodeFunctionData({\n        abi: singleAddressResolverAbi,\n        functionName: 'addr',\n        args: [namehash(name)]\n      })],\n      blockNumber,\n      blockTag\n    });\n    if (res[0] === '0x') return null;\n    const address = decodeFunctionResult({\n      abi: singleAddressResolverAbi,\n      functionName: 'addr',\n      data: res[0]\n    });\n    return trim(address) === '0x00' ? null : address;\n  } catch (err) {\n    if (isNullUniversalResolverError(err, 'resolve')) return null;\n    throw err;\n  }\n}","map":{"version":3,"names":["singleAddressResolverAbi","universalResolverResolveAbi","decodeFunctionResult","encodeFunctionData","getChainContractAddress","trim","toHex","isNullUniversalResolverError","namehash","packetToBytes","readContract","getEnsAddress","client","_ref","blockNumber","blockTag","name","universalResolverAddress","universalResolverAddress_","chain","Error","contract","res","address","abi","functionName","args","data","err"],"sources":["/home/amarjeet/Amarjeet/realwareWeb3/metamask_sign/Dapp-Starter code/node_modules/viem/src/actions/ens/getEnsAddress.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  singleAddressResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { trim } from '../../utils/data/trim.js'\nimport { toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { namehash } from '../../utils/ens/namehash.js'\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsAddressParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** Name to get the address for. */\n    name: string\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address\n  }\n>\n\nexport type GetEnsAddressReturnType = Address | null\n\n/**\n * Gets address for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAddressParameters}\n * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAddress, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAddress = await getEnsAddress(client, {\n *   name: normalize('wagmi-dev.eth'),\n * })\n * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n */\nexport async function getEnsAddress<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    name,\n    universalResolverAddress: universalResolverAddress_,\n  }: GetEnsAddressParameters,\n): Promise<GetEnsAddressReturnType> {\n  let universalResolverAddress = universalResolverAddress_\n  if (!universalResolverAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver',\n    })\n  }\n\n  try {\n    const res = await readContract(client, {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolve',\n      args: [\n        toHex(packetToBytes(name)),\n        encodeFunctionData({\n          abi: singleAddressResolverAbi,\n          functionName: 'addr',\n          args: [namehash(name)],\n        }),\n      ],\n      blockNumber,\n      blockTag,\n    })\n\n    if (res[0] === '0x') return null\n\n    const address = decodeFunctionResult({\n      abi: singleAddressResolverAbi,\n      functionName: 'addr',\n      data: res[0],\n    })\n\n    return trim(address) === '0x00' ? null : address\n  } catch (err) {\n    if (isNullUniversalResolverError(err, 'resolve')) return null\n    throw err\n  }\n}\n"],"mappings":"AAIA,SACEA,wBAAwB,EACxBC,2BAA2B,QACtB,yBAAyB;AAGhC,SAASC,oBAAoB,QAAQ,yCAAyC;AAC9E,SAASC,kBAAkB,QAAQ,uCAAuC;AAC1E,SAASC,uBAAuB,QAAQ,sBAAsB;AAC9D,SAASC,IAAI,QAAQ,0BAA0B;AAC/C,SAASC,KAAK,QAAQ,+BAA+B;AACrD,SAASC,4BAA4B,QAAQ,2BAA2B;AACxE,SAASC,QAAQ,QAAQ,6BAA6B;AACtD,SAASC,aAAa,QAAQ,kCAAkC;AAChE,SAEEC,YAAY,QACP,2BAA2B;AAalC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,OAAO,eAAeC,aAAaA,CACjCC,MAAiC,EAAAC,IAAA,EAMP;EAAA,IAL1B;IACEC,WAAW;IACXC,QAAQ;IACRC,IAAI;IACJC,wBAAwB,EAAEC;EAAyB,CAC3B,GAAAL,IAAA;EAE1B,IAAII,wBAAwB,GAAGC,yBAAyB;EACxD,IAAI,CAACD,wBAAwB,EAAE;IAC7B,IAAI,CAACL,MAAM,CAACO,KAAK,EACf,MAAM,IAAIC,KAAK,CACb,oEAAoE,CACrE;IAEHH,wBAAwB,GAAGb,uBAAuB,CAAC;MACjDU,WAAW;MACXK,KAAK,EAAEP,MAAM,CAACO,KAAK;MACnBE,QAAQ,EAAE;KACX,CAAC;;EAGJ,IAAI;IACF,MAAMC,GAAG,GAAG,MAAMZ,YAAY,CAACE,MAAM,EAAE;MACrCW,OAAO,EAAEN,wBAAwB;MACjCO,GAAG,EAAEvB,2BAA2B;MAChCwB,YAAY,EAAE,SAAS;MACvBC,IAAI,EAAE,CACJpB,KAAK,CAACG,aAAa,CAACO,IAAI,CAAC,CAAC,EAC1Bb,kBAAkB,CAAC;QACjBqB,GAAG,EAAExB,wBAAwB;QAC7ByB,YAAY,EAAE,MAAM;QACpBC,IAAI,EAAE,CAAClB,QAAQ,CAACQ,IAAI,CAAC;OACtB,CAAC,CACH;MACDF,WAAW;MACXC;KACD,CAAC;IAEF,IAAIO,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,OAAO,IAAI;IAEhC,MAAMC,OAAO,GAAGrB,oBAAoB,CAAC;MACnCsB,GAAG,EAAExB,wBAAwB;MAC7ByB,YAAY,EAAE,MAAM;MACpBE,IAAI,EAAEL,GAAG,CAAC,CAAC;KACZ,CAAC;IAEF,OAAOjB,IAAI,CAACkB,OAAO,CAAC,KAAK,MAAM,GAAG,IAAI,GAAGA,OAAO;GACjD,CAAC,OAAOK,GAAG,EAAE;IACZ,IAAIrB,4BAA4B,CAACqB,GAAG,EAAE,SAAS,CAAC,EAAE,OAAO,IAAI;IAC7D,MAAMA,GAAG;;AAEb"},"metadata":{},"sourceType":"module","externalDependencies":[]}