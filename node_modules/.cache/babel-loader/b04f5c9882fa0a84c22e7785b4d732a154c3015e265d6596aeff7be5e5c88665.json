{"ast":null,"code":"// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js';\nimport { concat } from '../data/concat.js';\nimport { toHex } from '../encoding/toHex.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { validateTypedData } from '../typedData.js';\nexport function hashTypedData(_ref) {\n  let {\n    domain: domain_,\n    message,\n    primaryType,\n    types: types_\n  } = _ref;\n  const domain = typeof domain_ === 'undefined' ? {} : domain_;\n  const types = {\n    EIP712Domain: [typeof domain?.name === 'string' && {\n      name: 'name',\n      type: 'string'\n    }, domain?.version && {\n      name: 'version',\n      type: 'string'\n    }, typeof domain?.chainId === 'number' && {\n      name: 'chainId',\n      type: 'uint256'\n    }, domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address'\n    }, domain?.salt && {\n      name: 'salt',\n      type: 'bytes32'\n    }].filter(Boolean),\n    ...types_\n  };\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n  const parts = ['0x1901'];\n  if (domain) parts.push(hashDomain({\n    domain,\n    types: types\n  }));\n  if (primaryType !== 'EIP712Domain') {\n    parts.push(hashStruct({\n      data: message,\n      primaryType: primaryType,\n      types: types\n    }));\n  }\n  return keccak256(concat(parts));\n}\nfunction hashDomain(_ref2) {\n  let {\n    domain,\n    types\n  } = _ref2;\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types\n  });\n}\nfunction hashStruct(_ref3) {\n  let {\n    data,\n    primaryType,\n    types\n  } = _ref3;\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types\n  });\n  return keccak256(encoded);\n}\nfunction encodeData(_ref4) {\n  let {\n    data,\n    primaryType,\n    types\n  } = _ref4;\n  const encodedTypes = [{\n    type: 'bytes32'\n  }];\n  const encodedValues = [hashType({\n    primaryType,\n    types\n  })];\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name]\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n  return encodeAbiParameters(encodedTypes, encodedValues);\n}\nfunction hashType(_ref5) {\n  let {\n    primaryType,\n    types\n  } = _ref5;\n  const encodedHashType = toHex(encodeType({\n    primaryType,\n    types\n  }));\n  return keccak256(encodedHashType);\n}\nfunction encodeType(_ref6) {\n  let {\n    primaryType,\n    types\n  } = _ref6;\n  let result = '';\n  const unsortedDeps = findTypeDependencies({\n    primaryType,\n    types\n  });\n  unsortedDeps.delete(primaryType);\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    result += `${type}(${types[type].map(_ref7 => {\n      let {\n        name,\n        type: t\n      } = _ref7;\n      return `${t} ${name}`;\n    }).join(',')})`;\n  }\n  return result;\n}\nfunction findTypeDependencies(_ref8) {\n  let {\n    primaryType: primaryType_,\n    types\n  } = _ref8;\n  let results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n  const match = primaryType_.match(/^\\w*/u);\n  const primaryType = match?.[0];\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results;\n  }\n  results.add(primaryType);\n  for (const field of types[primaryType]) {\n    findTypeDependencies({\n      primaryType: field.type,\n      types\n    }, results);\n  }\n  return results;\n}\nfunction encodeField(_ref9) {\n  let {\n    types,\n    name,\n    type,\n    value\n  } = _ref9;\n  if (types[type] !== undefined) {\n    return [{\n      type: 'bytes32'\n    }, keccak256(encodeData({\n      data: value,\n      primaryType: type,\n      types\n    }))];\n  }\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : '';\n    value = `0x${prepend + value.slice(2)}`;\n    return [{\n      type: 'bytes32'\n    }, keccak256(value)];\n  }\n  if (type === 'string') return [{\n    type: 'bytes32'\n  }, keccak256(toHex(value))];\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['));\n    const typeValuePairs = value.map(item => encodeField({\n      name,\n      type: parsedType,\n      types,\n      value: item\n    }));\n    return [{\n      type: 'bytes32'\n    }, keccak256(encodeAbiParameters(typeValuePairs.map(_ref10 => {\n      let [t] = _ref10;\n      return t;\n    }), typeValuePairs.map(_ref11 => {\n      let [, v] = _ref11;\n      return v;\n    })))];\n  }\n  return [{\n    type\n  }, value];\n}","map":{"version":3,"names":["encodeAbiParameters","concat","toHex","keccak256","validateTypedData","hashTypedData","_ref","domain","domain_","message","primaryType","types","types_","EIP712Domain","name","type","version","chainId","verifyingContract","salt","filter","Boolean","parts","push","hashDomain","hashStruct","data","_ref2","_ref3","encoded","encodeData","_ref4","encodedTypes","encodedValues","hashType","field","value","encodeField","_ref5","encodedHashType","encodeType","_ref6","result","unsortedDeps","findTypeDependencies","delete","deps","Array","from","sort","map","_ref7","t","join","_ref8","primaryType_","results","arguments","length","undefined","Set","match","has","add","_ref9","prepend","slice","lastIndexOf","parsedType","typeValuePairs","item","_ref10","_ref11","v"],"sources":["/home/amarjeet/Amarjeet/realwareWeb3/metamask_sign/Dapp-Starter code/node_modules/viem/src/utils/signature/hashTypedData.ts"],"sourcesContent":["// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { toHex } from '../encoding/toHex.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport { validateTypedData } from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  TTypedData extends TypedData | { [key: string]: unknown } = TypedData,\n  TPrimaryType extends string = string,\n> = TypedDataDefinition<TTypedData, TPrimaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport function hashTypedData<\n  TTypedData extends TypedData | { [key: string]: unknown },\n  TPrimaryType extends string = string,\n>({\n  domain: domain_,\n  message,\n  primaryType,\n  types: types_,\n}: HashTypedDataParameters<TTypedData, TPrimaryType>): HashTypedDataReturnType {\n  const domain: TypedDataDomain = typeof domain_ === 'undefined' ? {} : domain_\n  const types = {\n    EIP712Domain: [\n      typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n      domain?.version && { name: 'version', type: 'string' },\n      typeof domain?.chainId === 'number' && {\n        name: 'chainId',\n        type: 'uint256',\n      },\n      domain?.verifyingContract && {\n        name: 'verifyingContract',\n        type: 'address',\n      },\n      domain?.salt && { name: 'salt', type: 'bytes32' },\n    ].filter(Boolean),\n    ...(types_ as TTypedData),\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  } as TypedDataDefinition)\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain') {\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType: primaryType as string,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n  }\n\n  return keccak256(concat(parts))\n}\n\nfunction hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\nfunction hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\nfunction encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}