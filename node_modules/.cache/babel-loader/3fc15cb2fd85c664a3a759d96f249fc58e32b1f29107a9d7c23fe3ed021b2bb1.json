{"ast":null,"code":"import { getAbiItem } from '../../utils/abi/getAbiItem.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { createContractEventFilter } from './createContractEventFilter.js';\nimport { getBlockNumber } from './getBlockNumber.js';\nimport { getFilterChanges } from './getFilterChanges.js';\nimport { getLogs } from './getLogs.js';\nimport { uninstallFilter } from './uninstallFilter.js';\n/**\n * Watches and returns emitted contract event logs.\n *\n * - Docs: https://viem.sh/docs/contract/watchContractEvent.html\n *\n * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs).\n *\n * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchContractEventParameters}\n * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchContractEvent } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchContractEvent(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n *   eventName: 'Transfer',\n *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchContractEvent(client, _ref) {\n  let {\n    abi,\n    address,\n    args,\n    batch = true,\n    eventName,\n    onError,\n    onLogs,\n    pollingInterval = client.pollingInterval,\n    strict: strict_\n  } = _ref;\n  const observerId = stringify(['watchContractEvent', address, args, batch, client.uid, eventName, pollingInterval]);\n  const strict = strict_ ?? false;\n  return observe(observerId, {\n    onLogs,\n    onError\n  }, emit => {\n    let previousBlockNumber;\n    let filter;\n    let initialized = false;\n    const unwatch = poll(async () => {\n      if (!initialized) {\n        try {\n          filter = await createContractEventFilter(client, {\n            abi,\n            address,\n            args,\n            eventName,\n            strict\n          });\n        } catch {}\n        initialized = true;\n        return;\n      }\n      try {\n        let logs;\n        if (filter) {\n          logs = await getFilterChanges(client, {\n            filter\n          });\n        } else {\n          // If the filter doesn't exist, we will fall back to use `getLogs`.\n          // The fall back exists because some RPC Providers do not support filters.\n          // Fetch the block number to use for `getLogs`.\n          const blockNumber = await getBlockNumber(client);\n          // If the block number has changed, we will need to fetch the logs.\n          // If the block number doesn't exist, we are yet to reach the first poll interval,\n          // so do not emit any logs.\n          if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n            logs = await getLogs(client, {\n              address,\n              args,\n              fromBlock: previousBlockNumber + 1n,\n              toBlock: blockNumber,\n              event: getAbiItem({\n                abi,\n                name: eventName\n              })\n            });\n          } else {\n            logs = [];\n          }\n          previousBlockNumber = blockNumber;\n        }\n        if (logs.length === 0) return;\n        if (batch) emit.onLogs(logs);else logs.forEach(log => emit.onLogs([log]));\n      } catch (err) {\n        emit.onError?.(err);\n      }\n    }, {\n      emitOnBegin: true,\n      interval: pollingInterval\n    });\n    return async () => {\n      if (filter) await uninstallFilter(client, {\n        filter\n      });\n      unwatch();\n    };\n  });\n}","map":{"version":3,"names":["getAbiItem","observe","poll","stringify","createContractEventFilter","getBlockNumber","getFilterChanges","getLogs","uninstallFilter","watchContractEvent","client","_ref","abi","address","args","batch","eventName","onError","onLogs","pollingInterval","strict","strict_","observerId","uid","emit","previousBlockNumber","filter","initialized","unwatch","logs","blockNumber","fromBlock","toBlock","event","name","length","forEach","log","err","emitOnBegin","interval"],"sources":["/home/amarjeet/Amarjeet/realwareWeb3/metamask_sign/Dapp-Starter code/node_modules/viem/src/actions/public/watchContractEvent.ts"],"sourcesContent":["import type { Abi, Address, ExtractAbiEvent, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { GetEventArgs, InferEventName } from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport {\n  type GetAbiItemParameters,\n  getAbiItem,\n} from '../../utils/abi/getAbiItem.js'\nimport { observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport {\n  type CreateContractEventFilterParameters,\n  createContractEventFilter,\n} from './createContractEventFilter.js'\nimport { getBlockNumber } from './getBlockNumber.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { type GetLogsParameters, getLogs } from './getLogs.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type OnLogsParameter<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n  TStrict extends boolean | undefined = undefined,\n> = TAbi extends Abi\n  ? Log<bigint, number, ExtractAbiEvent<TAbi, TEventName>, TStrict>[]\n  : Log[]\nexport type OnLogsFn<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n  TStrict extends boolean | undefined = undefined,\n> = (logs: OnLogsParameter<TAbi, TEventName, TStrict>) => void\n\nexport type WatchContractEventParameters<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n  TStrict extends boolean | undefined = undefined,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[]\n  /** Contract ABI. */\n  abi: Narrow<TAbi>\n  args?: GetEventArgs<TAbi, TEventName>\n  /** Whether or not the event logs should be batched on each invocation. */\n  batch?: boolean\n  /** Contract event. */\n  eventName?: InferEventName<TAbi, TEventName>\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** The callback to call when new event logs are received. */\n  onLogs: OnLogsFn<TAbi, TEventName, TStrict>\n  /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */\n  pollingInterval?: number\n  /**\n   * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n   * @default false\n   */\n  strict?: TStrict\n}\n\nexport type WatchContractEventReturnType = () => void\n\n/**\n * Watches and returns emitted contract event logs.\n *\n * - Docs: https://viem.sh/docs/contract/watchContractEvent.html\n *\n * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs).\n *\n * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchContractEventParameters}\n * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchContractEvent } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchContractEvent(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n *   eventName: 'Transfer',\n *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchContractEvent<\n  TChain extends Chain | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string,\n  TStrict extends boolean | undefined = undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    abi,\n    address,\n    args,\n    batch = true,\n    eventName,\n    onError,\n    onLogs,\n    pollingInterval = client.pollingInterval,\n    strict: strict_,\n  }: WatchContractEventParameters<TAbi, TEventName, TStrict>,\n): WatchContractEventReturnType {\n  const observerId = stringify([\n    'watchContractEvent',\n    address,\n    args,\n    batch,\n    client.uid,\n    eventName,\n    pollingInterval,\n  ])\n  const strict = strict_ ?? false\n\n  return observe(observerId, { onLogs, onError }, (emit) => {\n    let previousBlockNumber: bigint\n    let filter: Filter<'event', TAbi, TEventName> | undefined\n    let initialized = false\n\n    const unwatch = poll(\n      async () => {\n        if (!initialized) {\n          try {\n            filter = (await createContractEventFilter(client, {\n              abi,\n              address,\n              args,\n              eventName,\n              strict,\n            } as unknown as CreateContractEventFilterParameters)) as Filter<\n              'event',\n              TAbi,\n              TEventName\n            >\n          } catch {}\n          initialized = true\n          return\n        }\n\n        try {\n          let logs: Log[]\n          if (filter) {\n            logs = await getFilterChanges(client, { filter })\n          } else {\n            // If the filter doesn't exist, we will fall back to use `getLogs`.\n            // The fall back exists because some RPC Providers do not support filters.\n\n            // Fetch the block number to use for `getLogs`.\n            const blockNumber = await getBlockNumber(client)\n\n            // If the block number has changed, we will need to fetch the logs.\n            // If the block number doesn't exist, we are yet to reach the first poll interval,\n            // so do not emit any logs.\n            if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n              logs = await getLogs(client, {\n                address,\n                args,\n                fromBlock: previousBlockNumber + 1n,\n                toBlock: blockNumber,\n                event: getAbiItem({\n                  abi,\n                  name: eventName,\n                } as unknown as GetAbiItemParameters),\n              } as unknown as GetLogsParameters)\n            } else {\n              logs = []\n            }\n            previousBlockNumber = blockNumber\n          }\n\n          if (logs.length === 0) return\n          if (batch) emit.onLogs(logs as any)\n          else logs.forEach((log) => emit.onLogs([log] as any))\n        } catch (err) {\n          emit.onError?.(err as Error)\n        }\n      },\n      {\n        emitOnBegin: true,\n        interval: pollingInterval,\n      },\n    )\n\n    return async () => {\n      if (filter) await uninstallFilter(client, { filter })\n      unwatch()\n    }\n  })\n}\n"],"mappings":"AAQA,SAEEA,UAAU,QACL,+BAA+B;AACtC,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,IAAI,QAAQ,qBAAqB;AAC1C,SAASC,SAAS,QAAQ,0BAA0B;AAEpD,SAEEC,yBAAyB,QACpB,gCAAgC;AACvC,SAASC,cAAc,QAAQ,qBAAqB;AACpD,SAASC,gBAAgB,QAAQ,uBAAuB;AACxD,SAAiCC,OAAO,QAAQ,cAAc;AAC9D,SAASC,eAAe,QAAQ,sBAAsB;AA4CtD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,OAAM,SAAUC,kBAAkBA,CAMhCC,MAAiC,EAAAC,IAAA,EAWyB;EAAA,IAV1D;IACEC,GAAG;IACHC,OAAO;IACPC,IAAI;IACJC,KAAK,GAAG,IAAI;IACZC,SAAS;IACTC,OAAO;IACPC,MAAM;IACNC,eAAe,GAAGT,MAAM,CAACS,eAAe;IACxCC,MAAM,EAAEC;EAAO,CACyC,GAAAV,IAAA;EAE1D,MAAMW,UAAU,GAAGnB,SAAS,CAAC,CAC3B,oBAAoB,EACpBU,OAAO,EACPC,IAAI,EACJC,KAAK,EACLL,MAAM,CAACa,GAAG,EACVP,SAAS,EACTG,eAAe,CAChB,CAAC;EACF,MAAMC,MAAM,GAAGC,OAAO,IAAI,KAAK;EAE/B,OAAOpB,OAAO,CAACqB,UAAU,EAAE;IAAEJ,MAAM;IAAED;EAAO,CAAE,EAAGO,IAAI,IAAI;IACvD,IAAIC,mBAA2B;IAC/B,IAAIC,MAAqD;IACzD,IAAIC,WAAW,GAAG,KAAK;IAEvB,MAAMC,OAAO,GAAG1B,IAAI,CAClB,YAAW;MACT,IAAI,CAACyB,WAAW,EAAE;QAChB,IAAI;UACFD,MAAM,GAAI,MAAMtB,yBAAyB,CAACM,MAAM,EAAE;YAChDE,GAAG;YACHC,OAAO;YACPC,IAAI;YACJE,SAAS;YACTI;WACiD,CAIlD;SACF,CAAC,MAAM;QACRO,WAAW,GAAG,IAAI;QAClB;;MAGF,IAAI;QACF,IAAIE,IAAW;QACf,IAAIH,MAAM,EAAE;UACVG,IAAI,GAAG,MAAMvB,gBAAgB,CAACI,MAAM,EAAE;YAAEgB;UAAM,CAAE,CAAC;SAClD,MAAM;UACL;UACA;UAEA;UACA,MAAMI,WAAW,GAAG,MAAMzB,cAAc,CAACK,MAAM,CAAC;UAEhD;UACA;UACA;UACA,IAAIe,mBAAmB,IAAIA,mBAAmB,KAAKK,WAAW,EAAE;YAC9DD,IAAI,GAAG,MAAMtB,OAAO,CAACG,MAAM,EAAE;cAC3BG,OAAO;cACPC,IAAI;cACJiB,SAAS,EAAEN,mBAAmB,GAAG,EAAE;cACnCO,OAAO,EAAEF,WAAW;cACpBG,KAAK,EAAEjC,UAAU,CAAC;gBAChBY,GAAG;gBACHsB,IAAI,EAAElB;eAC4B;aACL,CAAC;WACnC,MAAM;YACLa,IAAI,GAAG,EAAE;;UAEXJ,mBAAmB,GAAGK,WAAW;;QAGnC,IAAID,IAAI,CAACM,MAAM,KAAK,CAAC,EAAE;QACvB,IAAIpB,KAAK,EAAES,IAAI,CAACN,MAAM,CAACW,IAAW,CAAC,MAC9BA,IAAI,CAACO,OAAO,CAAEC,GAAG,IAAKb,IAAI,CAACN,MAAM,CAAC,CAACmB,GAAG,CAAQ,CAAC,CAAC;OACtD,CAAC,OAAOC,GAAG,EAAE;QACZd,IAAI,CAACP,OAAO,GAAGqB,GAAY,CAAC;;IAEhC,CAAC,EACD;MACEC,WAAW,EAAE,IAAI;MACjBC,QAAQ,EAAErB;KACX,CACF;IAED,OAAO,YAAW;MAChB,IAAIO,MAAM,EAAE,MAAMlB,eAAe,CAACE,MAAM,EAAE;QAAEgB;MAAM,CAAE,CAAC;MACrDE,OAAO,EAAE;IACX,CAAC;EACH,CAAC,CAAC;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}